# Full Stack Chat Application:
- Frontend: React, TailwindCSS, DaisyUI, Lucide
- Backend: Node, Express, Socket.io
- Database: MongoDB, Cloudinary (images)
- Build: Vite
- State Management: Zustand

---
## Features

1. User registration, logins, logout, profile image
2. User authentication with JWT
3. User messaging (text, pictures) 
4. Realtime messaging and online status with websockets (socket.io)

---
## MongoDB Schema

1. users
    - _id (Auto-generate by MongoDB)
    - email
    - fullName
    - password
    - profilePic
    - createdAt
    - updatedAt

2. messages
    - _id (Auto-generated by MongoDB)
    - senderID
    - receiverId
    - text
    - image
    - createdAt
---
## Authentication (JWT) Workflow:

### Initial Requests: 
1. Registration: 
    - Client (request to /api/auth/signup) to server
    - Server (connects to DB, creates user, sends response back to client)

2. Login:
    - Client (request to /api/auth/login) to API Gateway
    - Server (checks user credentials from DB, sends response)
    
JWT (on successful signup and login):
    - Server creates JWT and stores it in cookies

### Subsequent Requests:

1. Check authentication (on refreshs, protected routes)
2. Retrieving other users
2. Sending messages
3. Retrieving messages 
4. Establishing websocket connection

JWT (on subseqent requests)
    - User/Client creates and sends a requests with JWT cookie
    - Server receives JWT and validates it
    - Server grants access or error response back

---
## Checklist (Deployed)
- Setup backend (Node, Express)
- Setup MongoDB connection, schema, models
    - user schema and model
    - message schema and model

- Cloudinary connection for image uploads

- Create authentication router and controllers
    - POST register API endpoint and controller
    - POST login API endpoint and controller
    - POST logout API endpoint and controller
    - PUT update API endpoint and controller
    - GET checkAuth API endpoint and controller

- JWT creation and middleware validation 

- Password encryption (BCrypt)

- Message routers and controllers 
    - GET users for chats 
    - GET messages using Id 
    - POST messages

- Setup frontend (React, Zustand, DaisyUI, TailwindCSS)
    - pages creation, routing and authentication check 
    - setup Zustand global state management
    - signup, login, profile, settings page UX/UI
    - sidebar, chatbox, chat input components

- Realtime Features with socket.io 
    - create express -> HTTP -> socket server
    - replace backend and frontend logic
    - user instance socket connection events (login, signup, logout, auth)
    - server to client events (online users, new messages)
    - show online only toggle feature on homepage
    - update autoscroll to end in message history on event

Deployment 
    - dynamic routing
    - build static assets
    - deploy on Render

- Bug/Features/Improvements (Currently working)
    - image sends do not scroll all the way done in the chatbox
    - centralize socket entries and sub/unsub into a single point
    - create user defined friends and groups (take away the MVP feature of global chat)
    - Integrate LLM (accounts and behavior) to simulate the Mafia Game in group chats.

## Socket.io (https://socket.io/docs/v3): What did I learn
- A library that enables real-time bidirectional and event-based communication between browser and server. 
- Parts (1) Node.js server (2) javascript client library for browser
- WebSockets are a communication protocol for full duplex, low-latency communication. It's a standardized protocol with high interoperability, but with manual handling and no automatic reconnections. 
- Socket.io is a javascript libarary that uses WebSockets when available, and falls back to HTTP long-polling otherwise. This means automatic reconnection, with event based messaging (pub/sub abstraction). Since it's javascript heavy and we will be using express, it has middleware support.  
- For this application, we'll be running the socket.io library in the backend, and sokcet.io-client in React.
- Express is built on top of built-in Node.js **HTTP** module. It provides a level of abstraction, middleware, and ease of use. However, unless we handle the return value explicitly, we miss out on direct access to the HTTP server. 
- Building on top of expres with **http.createServer(app)** allows direct access, integration with WebSockets, and low-level events. 
- Steps
    - Handshake between client and server
    - Sends data (HTTP long-polling)
    - Receive data (HTTP long-polling)
    - Upgrade (WebSocket)
    - Receive data (HTTP long-polling is closed once WebSocket connection is established)
 
---
## Goal:

Learn things not taught in school (front end, backend, frameworks, APIs, sockets, state management, JWT best practices, desiging a full application, etc). 
More exposure to backend APIs, sockets and password encryption. The most difficult part was desiging the user and data flow. 
Burak Orkmez's resources and courses were a great place to follow along and compare how I built a part vs how he did. The process followed the general steps of designing and building, comparing, researching the **why**, and iterating to reform my decision making. Starting from zero, this process was much better than blindly following a tutorial. 

