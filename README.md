# Full Stack Chat Application:
- Frontend: React, TailwindCSS, DaisyUI, Lucide
- Backend: Node, Express, Socket.io
- Database: MongoDB, Cloudinary (images)
- Build: Vite
- State Management: Zustand
---
## Goal:
This was a personal project, following along Burak Orkmez's course (https://www.udemy.com/course/the-web-dev-bootcamp/?couponCode=DA64BA3F36F6D786D143).
My personal goal for this project was more exposure to backend API creation, and first time use of websockets. 
---
## Features
1. User registration, logins
2. User authentication with JWT
3. User messaging (text, pictures) 
4. Realtime functionality with websockets (socket.io)
5. online user status
---
## MongoDB Schema
1. users
    - _id (Auto-generate by MongoDB)
    - email
    - fullName
    - password
    - profilePic
    - createdAt
    - updatedAt
2. messages
    - _id (Auto-generated by MongoDB)
    - senderID
    - receiverId
    - text
    - image
    - createdAt
---
## Authentication (JWT) Workflow:

### Initial Requests: 
1. Signup: 
- Client (request to /api/auth/signup) to server
- Server (connects to DB, creates user, sends response back to client)

2. Login:
- Client (request to /api/auth/login) to API Gateway
- Server (checks user credentials from DB, sends response)
    
3. JWT (on successful signup and login):
- Server creates JWT and stores it in cookies

### Subsequent Requests:
- User/Client creates and sends a requests with JWT cookie
- Server receives JWT and validates it
- Server grants access or error response back

1. Check authentication (on refreshs, protected routes)
2. Retrieving other users
2. Sending messages
3. Retrieving messages 
---
## Checklist (local)
- create project and install dependencies (done)
- Setup backend (Node, Express) (done)
- Setup MongoDB connection and test (done)
    - user schema and model (done)
    - message schema and model (done)
- Cloudinary connection for image uploads (done)
- Create authentication router and controllers (done)
    - POST register API endpoint and controller (done)
    - POST login API endpoint and controller (done)
    - POST logout API endpoint and controller (done)
    - PUT update API endpoint and controller (done)
    - GET checkAuth API endpoint and controller (done)
- JWT creation and middleware validation (done)
- Password encryption with Bcrypt hashing (done)
- Create mesasges router and controllers (done)
    - GET users for chats (done)
    - GET messages using Id (done)
    - POST messages (done) 
- Frontend install and dependences (done)
    - basic pages creation and routing (done)
    - create global state using zustand (done)
    - check user authentication on refresh (done)
    - Signup Page UI and interaction (done)
    - Login Page UI and interaction (done)
    - Profile Page UI and interaction (done)
    - Import DaisyUI themes, build settings page with preview (done)
    - Working homepage sidebar (done)
    - message API post request with text and images (done)
    - display message history with images, text, timestamps (done)
- Realtime Features with socket.io (working)
    - create express -> HTTP (explicit) -> socket server
    - replace backend (done)
    - replace frontend
        - login -> connect (done)
        - signup -> connect (done)
        - logout -> disconnect(done)
        - check auth -> connect (done)
    - Logging online user events, implement UX (done)
    - Receiving messages in real time (done)
    - update scroll in ChatContainer (done)
    - show online only toggle (done)
- Deploy
    - dynamic routing using env (done)
    - build scripts (done)
    - deploy together and test (working)


- Bug/Features/Improvements
    - image sends do not scroll all the way done
    - centralize socket entries and sub/unsub into a single point


## Socket.io (https://socket.io/docs/v3): What did I learn
- library that enables real-time bidirectional and event-based communication between browser and server. 
- Parts (1) Node.js server (2) javascript client library for browser
- WebSockets are a communication protocol for full duplex, low-latency communication. It's a standardized protocol with high interoperability, but with manual handling and no automatic reconnections. 
- socketIO is a javascript libarary that uses WebSockets when available, and falls back to HTTP long-polling otherwise. This means automatic reconnection, with event based messaging (pub/sub abstraction). Since it's javascript heavy and we will be using express, it has middleware support.  
- For this application, we'll be running the socket.io library in the backend, and sokcet.io-client in React.
- Express is built on top of built-in Node.js **HTTP** module. It provides a level of abstraction, middleware, and ease of use. However, unless we handle the return value explicitly, we miss out on direct access to the HTTP server. 
- Building on top of expres with **http.createServer(app)** allows direct access, integration with WebSockets, and low-level events. 
- Steps
    - Handshake between client and server
    - Sends data (HTTP long-polling)
    - Receive data (HTTP long-polling)
    - Upgrade (WebSocket)
    - Receive data (HTTP long-polling is closed once WebSocket connection is established)
- socket.emit() vs io.emit()
